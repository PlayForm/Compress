import { AstroError, AstroErrorData } from "../core/errors/index.js";
import { isLocalService } from "./services/service.js";
function injectImageEndpoint(settings) {
  settings.injectedRoutes.push({
    pattern: "/_image",
    entryPoint: "astro/assets/image-endpoint",
    prerender: false
  });
  return settings;
}
function isESMImportedImage(src) {
  return typeof src === "object";
}
async function getConfiguredImageService() {
  var _a;
  if (!((_a = globalThis == null ? void 0 : globalThis.astroAsset) == null ? void 0 : _a.imageService)) {
    const { default: service } = await import(
      // @ts-expect-error
      "virtual:image-service"
    ).catch((e) => {
      const error = new AstroError(AstroErrorData.InvalidImageService);
      error.cause = e;
      throw error;
    });
    if (!globalThis.astroAsset)
      globalThis.astroAsset = {};
    globalThis.astroAsset.imageService = service;
    return service;
  }
  return globalThis.astroAsset.imageService;
}
async function getImage(options, serviceConfig) {
  if (!options || typeof options !== "object") {
    throw new AstroError({
      ...AstroErrorData.ExpectedImageOptions,
      message: AstroErrorData.ExpectedImageOptions.message(JSON.stringify(options))
    });
  }
  const service = await getConfiguredImageService();
  const validatedOptions = service.validateOptions ? await service.validateOptions(options, serviceConfig) : options;
  let imageURL = await service.getURL(validatedOptions, serviceConfig);
  if (isLocalService(service) && globalThis.astroAsset.addStaticImage) {
    imageURL = globalThis.astroAsset.addStaticImage(validatedOptions);
  }
  return {
    rawOptions: options,
    options: validatedOptions,
    src: imageURL,
    attributes: service.getHTMLAttributes !== void 0 ? service.getHTMLAttributes(validatedOptions, serviceConfig) : {}
  };
}
export {
  getConfiguredImageService,
  getImage,
  injectImageEndpoint,
  isESMImportedImage
};
