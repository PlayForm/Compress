import * as colors from "kleur/colors";
import fs from "node:fs";
import { performance } from "node:perf_hooks";
import { fileURLToPath } from "node:url";
import { injectImageEndpoint } from "../../assets/internal.js";
import { telemetry } from "../../events/index.js";
import { eventCliSession } from "../../events/session.js";
import {
  runHookBuildDone,
  runHookBuildStart,
  runHookConfigDone,
  runHookConfigSetup
} from "../../integrations/index.js";
import { isServerLikeOutput } from "../../prerender/utils.js";
import { resolveConfig } from "../config/config.js";
import { createNodeLogging } from "../config/logging.js";
import { createSettings } from "../config/settings.js";
import { createVite } from "../create-vite.js";
import { debug, info, levels, timerMessage, warn } from "../logger/core.js";
import { apply as applyPolyfill } from "../polyfill.js";
import { RouteCache } from "../render/route-cache.js";
import { createRouteManifest } from "../routing/index.js";
import { collectPagesData } from "./page-data.js";
import { staticBuild, viteBuild } from "./static-build.js";
import { getTimeStat } from "./util.js";
async function build(inlineConfig, options) {
  applyPolyfill();
  const logging = createNodeLogging(inlineConfig);
  const { userConfig, astroConfig } = await resolveConfig(inlineConfig, "build");
  telemetry.record(eventCliSession("build", userConfig));
  const settings = createSettings(astroConfig, fileURLToPath(astroConfig.root));
  const builder = new AstroBuilder(settings, {
    ...options,
    logging,
    mode: inlineConfig.mode
  });
  await builder.run();
}
class AstroBuilder {
  constructor(settings, options) {
    this.mode = "production";
    if (options.mode) {
      this.mode = options.mode;
    }
    this.settings = settings;
    this.logging = options.logging;
    this.teardownCompiler = options.teardownCompiler ?? false;
    this.routeCache = new RouteCache(this.logging);
    this.origin = settings.config.site ? new URL(settings.config.site).origin : `http://localhost:${settings.config.server.port}`;
    this.manifest = { routes: [] };
    this.timer = {};
  }
  /** Setup Vite and run any async setup logic that couldn't run inside of the constructor. */
  async setup() {
    debug("build", "Initial setup...");
    const { logging } = this;
    this.timer.init = performance.now();
    this.settings = await runHookConfigSetup({
      settings: this.settings,
      command: "build",
      logging
    });
    if (this.settings.config.experimental.assets && isServerLikeOutput(this.settings.config)) {
      this.settings = injectImageEndpoint(this.settings);
    }
    this.manifest = createRouteManifest({ settings: this.settings }, this.logging);
    const viteConfig = await createVite(
      {
        mode: this.mode,
        server: {
          hmr: false,
          middlewareMode: true
        }
      },
      { settings: this.settings, logging, mode: "build", command: "build" }
    );
    await runHookConfigDone({ settings: this.settings, logging });
    const { syncInternal } = await import("../sync/index.js");
    const syncRet = await syncInternal(this.settings, { logging, fs });
    if (syncRet !== 0) {
      return process.exit(syncRet);
    }
    return { viteConfig };
  }
  /** Run the build logic. build() is marked private because usage should go through ".run()" */
  async build({ viteConfig }) {
    await runHookBuildStart({ config: this.settings.config, logging: this.logging });
    this.validateConfig();
    info(this.logging, "build", `output target: ${colors.green(this.settings.config.output)}`);
    if (this.settings.adapter) {
      info(this.logging, "build", `deploy adapter: ${colors.green(this.settings.adapter.name)}`);
    }
    info(this.logging, "build", "Collecting build info...");
    this.timer.loadStart = performance.now();
    const { assets, allPages } = await collectPagesData({
      settings: this.settings,
      logging: this.logging,
      manifest: this.manifest
    });
    debug("build", timerMessage("All pages loaded", this.timer.loadStart));
    const pageNames = [];
    this.timer.buildStart = performance.now();
    info(
      this.logging,
      "build",
      colors.dim(`Completed in ${getTimeStat(this.timer.init, performance.now())}.`)
    );
    const opts = {
      allPages,
      settings: this.settings,
      logging: this.logging,
      manifest: this.manifest,
      mode: this.mode,
      origin: this.origin,
      pageNames,
      routeCache: this.routeCache,
      teardownCompiler: this.teardownCompiler,
      viteConfig
    };
    const { internals } = await viteBuild(opts);
    await staticBuild(opts, internals);
    this.timer.assetsStart = performance.now();
    Object.keys(assets).map((k) => {
      if (!assets[k])
        return;
      const filePath = new URL(`file://${k}`);
      fs.mkdirSync(new URL("./", filePath), { recursive: true });
      fs.writeFileSync(filePath, assets[k], "utf8");
      delete assets[k];
    });
    debug("build", timerMessage("Additional assets copied", this.timer.assetsStart));
    await runHookBuildDone({
      config: this.settings.config,
      pages: pageNames,
      routes: Object.values(allPages).map((pd) => pd.route),
      logging: this.logging
    });
    if (this.logging.level && levels[this.logging.level] <= levels["info"]) {
      await this.printStats({
        logging: this.logging,
        timeStart: this.timer.init,
        pageCount: pageNames.length,
        buildMode: this.settings.config.output
      });
    }
    this.settings.timer.writeStats();
  }
  /** Build the given Astro project.  */
  async run() {
    const setupData = await this.setup();
    try {
      await this.build(setupData);
    } catch (_err) {
      throw _err;
    }
  }
  validateConfig() {
    const { config } = this.settings;
    if (config.outDir.toString() === config.root.toString()) {
      throw new Error(
        `the outDir cannot be the root folder. Please build to a folder such as dist.`
      );
    }
    if (config.build.split === true) {
      if (config.output === "static") {
        warn(
          this.logging,
          "configuration",
          'The option `build.split` won\'t take effect, because `output` is not `"server"` or `"hybrid"`.'
        );
      }
    }
    if (config.build.excludeMiddleware === true) {
      if (config.output === "static") {
        warn(
          this.logging,
          "configuration",
          'The option `build.excludeMiddleware` won\'t take effect, because `output` is not `"server"` or `"hybrid"`.'
        );
      }
    }
    if (config.build.split === true) {
      if (config.output !== "server") {
        throw new Error(
          'The option `build.split` can only be used when `output` is set to `"server"`.'
        );
      }
    }
  }
  /** Stats */
  async printStats({
    logging,
    timeStart,
    pageCount,
    buildMode
  }) {
    const total = getTimeStat(timeStart, performance.now());
    let messages = [];
    if (buildMode === "static") {
      messages = [`${pageCount} page(s) built in`, colors.bold(total)];
    } else {
      messages = ["Server built in", colors.bold(total)];
    }
    info(logging, "build", messages.join(" "));
    info(logging, "build", `${colors.bold("Complete!")}`);
  }
}
export {
  build as default
};
